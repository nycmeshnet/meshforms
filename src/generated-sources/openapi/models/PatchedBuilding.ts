/* tslint:disable */
/* eslint-disable */
/**
 * MeshDB Data API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { AddressTruthSourcesEnum } from './AddressTruthSourcesEnum';
import {
    AddressTruthSourcesEnumFromJSON,
    AddressTruthSourcesEnumFromJSONTyped,
    AddressTruthSourcesEnumToJSON,
} from './AddressTruthSourcesEnum';
import type { BuildingNodesInner } from './BuildingNodesInner';
import {
    BuildingNodesInnerFromJSON,
    BuildingNodesInnerFromJSONTyped,
    BuildingNodesInnerToJSON,
} from './BuildingNodesInner';
import type { BuildingPrimaryNode } from './BuildingPrimaryNode';
import {
    BuildingPrimaryNodeFromJSON,
    BuildingPrimaryNodeFromJSONTyped,
    BuildingPrimaryNodeToJSON,
} from './BuildingPrimaryNode';
import type { BuildingInstallsInner } from './BuildingInstallsInner';
import {
    BuildingInstallsInnerFromJSON,
    BuildingInstallsInnerFromJSONTyped,
    BuildingInstallsInnerToJSON,
} from './BuildingInstallsInner';

/**
 * A  ModelSerializer MixIn which sets `NestedKeyObjectRelatedField` as the default field class
 * to use for the foreign key fields
 * @export
 * @interface PatchedBuilding
 */
export interface PatchedBuilding {
    /**
     * 
     * @type {string}
     * @memberof PatchedBuilding
     */
    readonly id?: string;
    /**
     * 
     * @type {Array<BuildingInstallsInner>}
     * @memberof PatchedBuilding
     */
    readonly installs?: Array<BuildingInstallsInner>;
    /**
     * NYC DOB Identifier for the structure containing this building
     * @type {number}
     * @memberof PatchedBuilding
     */
    bin?: number | null;
    /**
     * Line 1 only of the address of this building: i.e. <house num> <street>
     * @type {string}
     * @memberof PatchedBuilding
     */
    streetAddress?: string | null;
    /**
     * The name of the borough this building is in for buildings within NYC, "New York" for Manhattan to match street addresses. The actual city name for anything outside NYC
     * @type {string}
     * @memberof PatchedBuilding
     */
    city?: string | null;
    /**
     * The 2 letter abreviation of the US State this building is contained within, e.g. "NY" or "NJ"
     * @type {string}
     * @memberof PatchedBuilding
     */
    state?: string | null;
    /**
     * The five digit ZIP code this building is contained within
     * @type {string}
     * @memberof PatchedBuilding
     */
    zipCode?: string | null;
    /**
     * A list of strings that answers the question: How was the content of the street address, city, state, and ZIP fields determined? This is useful in understanding the level of validation applied to spreadsheet imported data. Possible values are: OSMNominatim, OSMNominatimZIPOnly, NYCPlanningLabs, PeliasStringParsing, ReverseGeocodeFromCoordinates, HumanEntry. Check the import script for details
     * @type {Array<AddressTruthSourcesEnum>}
     * @memberof PatchedBuilding
     */
    addressTruthSources?: Array<AddressTruthSourcesEnum>;
    /**
     * Building latitude in decimal degrees
     * @type {number}
     * @memberof PatchedBuilding
     */
    latitude?: number;
    /**
     * Building longitude in decimal degrees
     * @type {number}
     * @memberof PatchedBuilding
     */
    longitude?: number;
    /**
     * Building rooftop altitude in "absolute" meters above mean sea level
     * @type {number}
     * @memberof PatchedBuilding
     */
    altitude?: number | null;
    /**
     * A free-form text description of this building, to track any additional information. For Buidings imported from the spreadsheet, this starts with a formatted block of information about the import process and original spreadsheet data. However this structure can be changed by admins at any time and should not be relied on by automated systems. 
     * @type {string}
     * @memberof PatchedBuilding
     */
    notes?: string | null;
    /**
     * Panoramas taken from the roof of this Building
     * @type {Array<string>}
     * @memberof PatchedBuilding
     */
    panoramas?: Array<string> | null;
    /**
     * 
     * @type {BuildingPrimaryNode}
     * @memberof PatchedBuilding
     */
    primaryNode?: BuildingPrimaryNode | null;
    /**
     * All nodes located on the same structure (i.e. a discrete man-made place identified by the same BIN) that this Building is located within.
     * @type {Array<BuildingNodesInner>}
     * @memberof PatchedBuilding
     */
    nodes?: Array<BuildingNodesInner>;
}

/**
 * Check if a given object implements the PatchedBuilding interface.
 */
export function instanceOfPatchedBuilding(value: object): value is PatchedBuilding {
    return true;
}

export function PatchedBuildingFromJSON(json: any): PatchedBuilding {
    return PatchedBuildingFromJSONTyped(json, false);
}

export function PatchedBuildingFromJSONTyped(json: any, ignoreDiscriminator: boolean): PatchedBuilding {
    if (json == null) {
        return json;
    }
    return {
        
        'id': json['id'] == null ? undefined : json['id'],
        'installs': json['installs'] == null ? undefined : ((json['installs'] as Array<any>).map(BuildingInstallsInnerFromJSON)),
        'bin': json['bin'] == null ? undefined : json['bin'],
        'streetAddress': json['street_address'] == null ? undefined : json['street_address'],
        'city': json['city'] == null ? undefined : json['city'],
        'state': json['state'] == null ? undefined : json['state'],
        'zipCode': json['zip_code'] == null ? undefined : json['zip_code'],
        'addressTruthSources': json['address_truth_sources'] == null ? undefined : ((json['address_truth_sources'] as Array<any>).map(AddressTruthSourcesEnumFromJSON)),
        'latitude': json['latitude'] == null ? undefined : json['latitude'],
        'longitude': json['longitude'] == null ? undefined : json['longitude'],
        'altitude': json['altitude'] == null ? undefined : json['altitude'],
        'notes': json['notes'] == null ? undefined : json['notes'],
        'panoramas': json['panoramas'] == null ? undefined : json['panoramas'],
        'primaryNode': json['primary_node'] == null ? undefined : BuildingPrimaryNodeFromJSON(json['primary_node']),
        'nodes': json['nodes'] == null ? undefined : ((json['nodes'] as Array<any>).map(BuildingNodesInnerFromJSON)),
    };
}

export function PatchedBuildingToJSON(value?: Omit<PatchedBuilding, 'id'|'installs'> | null): any {
    if (value == null) {
        return value;
    }
    return {
        
        'bin': value['bin'],
        'street_address': value['streetAddress'],
        'city': value['city'],
        'state': value['state'],
        'zip_code': value['zipCode'],
        'address_truth_sources': value['addressTruthSources'] == null ? undefined : ((value['addressTruthSources'] as Array<any>).map(AddressTruthSourcesEnumToJSON)),
        'latitude': value['latitude'],
        'longitude': value['longitude'],
        'altitude': value['altitude'],
        'notes': value['notes'],
        'panoramas': value['panoramas'],
        'primary_node': BuildingPrimaryNodeToJSON(value['primaryNode']),
        'nodes': value['nodes'] == null ? undefined : ((value['nodes'] as Array<any>).map(BuildingNodesInnerToJSON)),
    };
}

